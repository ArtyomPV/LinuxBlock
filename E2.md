
E2.3. Пользователи

E2.4. Группы

E2.5. Права на файлы

E2.6. Время и даты

# E2.2. Концепция и возможности пользователей в ОС Linux

Всего существует шесть различных видов файлов:

	Обычный файл (regular file).
	Каталог (directory).
	Специальный файл устройства (special device file).
	FIFO (first in, first out), или именованный канал (named pipe).
	Символьная ссылка (symbol link).
	Сокет (socket).
	
drwxrwxr-x 2 worker worker 4096 Sep 30 11:31 test_dir1

Первое поле -rw-rw-r-- обозначает доступ к файлу. В него могут входить 10 символов, и каждый символ что-то обозначает. Эти 10 символов поделены на четыре поля.

	тип файла						1 символ
	права доступа владельца user	3 символа
	права доступа группы			3 символа
	права доступа остальный 		3 символа
	
```
avp-home@avphome-VirtualBox:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
avp-home:x:1000:1000:avp-home,,,:/home/avp-home:/bin/bash
```

Значения разделены с помощью двоеточия (:) на 7 полей:
	Самое первое поле, читая слева, — это имя пользователя. Под этим именем пользователь заходит в систему, под ним отображаются запущенные процессы и прочее.
	Второе поле — это хеш (математический алгоритм, преобразовывающий произвольный массив данных в состоящую из букв и цифр строку фиксированной длины) пароля.
	Третье — идентификатор пользователя (user id, или uid).
	Четвёртое — идентификатор группы (group id, или gid).
	Пятое — информационное поле GECOS, где хранится вспомогательная информация о пользователе (номер телефона, адрес, полное имя и прочее).
	Шестое — домашняя директория, откуда начинает пользователь, войдя в операционную систему.
	Седьмое — оболочка пользователя.


Пользователь **root** — это специальный пользователь операционной системы, имеющий неограниченные права доступа. На него не действуют ограничения и правила, наложенные на других пользователей. Категорически не рекомендуется постоянно находиться залогиненным под root.

Если у вас уже есть пароль для root, то, чтобы залогиниться под root, используйте команду su -:

После правильного ввода пароля значок $ сменится на #, что будет означать — у вас root-привилегии.

получить привилегии root можно c помощью утилиты sudo

Sudo (substitute user and do — дословно «подменить пользователя и выполнить») — используется, чтобы зайти временно под суперпользователя и выполнить команду от имени root. 


# E2.3. Пользователи

## Useradd

```
root@localhost:~# useradd user1
```

```
avp-home@avphome-VirtualBox:~$ sudo useradd user1
[sudo] пароль для avp-home:

avp-home@avphome-VirtualBox:~$ tail -n 5 /etc/passwd

hplip:x:127:7:HPLIP system user,,,:/run/hplip:/bin/false
gdm:x:128:134:Gnome Display Manager:/var/lib/gdm3:/bin/false
avp-home:x:1000:1000:avp-home,,,:/home/avp-home:/bin/bash
sshd:x:129:65534::/run/sshd:/usr/sbin/nologin
user1:x:1001:1001::/home/user1:/bin/sh
```

указать пароль с помощью дополнительного ключа -p или полного ключа --password.

```
avp-home@avphome-VirtualBox:~$ sudo useradd -p123qwerty user2
avp-home@avphome-VirtualBox:~$ tail -n 5 /etc/passwd
gdm:x:128:134:Gnome Display Manager:/var/lib/gdm3:/bin/false
avp-home:x:1000:1000:avp-home,,,:/home/avp-home:/bin/bash
sshd:x:129:65534::/run/sshd:/usr/sbin/nologin
user1:x:1001:1001::/home/user1:/bin/sh
user2:x:1002:1002::/home/user2:/bin/sh
```

Для добавления пользователя в группу при создании используется ключ  -G, --groups.

```
avp-home@avphome-VirtualBox:~$ sudo useradd -p 1234qwer -G sudo user3
avp-home@avphome-VirtualBox:~$ tail -n 5 /etc/passwd
avp-home:x:1000:1000:avp-home,,,:/home/avp-home:/bin/bash
sshd:x:129:65534::/run/sshd:/usr/sbin/nologin
user1:x:1001:1001::/home/user1:/bin/sh
user2:x:1002:1002::/home/user2:/bin/sh
user3:x:1003:1003::/home/user3:/bin/sh
avp-home@avphome-VirtualBox:~$
```

Рассмотрев основные принципы создания пользователей, рассмотрим список ключей ниже:

	-d, --home-dir — для создания домашней директории пользователя. Если не указывать этот ключ, то будет создана домашняя директория в /home. Если его указать, то можно задать другое место для домашней директории, например, в директории /var. Может пригодиться, когда будете создавать пользователей для FTP.
	-m, --create-home — создаёт домашнюю директорию в /home. 
	-M, --no-create-home — не создает домашнюю директорию для пользователя.
	-u, --uid — требуется для того, что бы вручную задать uid пользователя.
	-r, -system — создаёт системного пользователя.
	-h, -help — выводит справку по useradd.
	
### passwd 

Она применяется для смены пароля пользователя

	root@localhost:~# passwd ключ аргумент
	
Ниже приведён список ключей команды работы с паролями:

	-d, --delete— удалить пароль пользователя (сделать его пустым). Это быстрый способ заблокировать пароль учётной записи. Это делает указанную учётную запись беспарольной.
	-i, --inactive <кол_во_дней> — этот параметр используется для блокировки учётной записи по прошествии заданного числа дней после устаревания пароля. То есть, если пароль устарел и прошло более указанных <кол_во_дней>, то пользователь больше не сможет использовать данную учётную запись.
	-m, --mindays <кол_во_дней> — задать минимальное количество дней между сменой пароля. Нулевое значение этого поля указывает на то, что пользователь может менять свой пароль, когда захочет.
	-w, --wardays <кол_во_дней> — установить число дней выдачи предупреждения, перед тем как потребуется смена пароля. В параметре <кол_во_дней> указывается число дней перед тем, как пароль устареет, в течение которых пользователю будут напоминать, что пароль скоро устареет.
	-x, --maxdays <кол_во_дней> — установить максимальное количество дней, в течение которых пароль остаётся рабочим. После <кол_во_дней> пароль нужно изменить.


Для смены пароля другому пользователю надо войти в режим суперпользователя или применить sudo:

```
avp-home@avphome-VirtualBox:~$ sudo passwd user1
Новый пароль:
Повторите ввод нового пароля:
passwd: пароль успешно обновлён
avp-home@avphome-VirtualBox:~$
```
Также будет полезен ключ -S, --status:
```
avp-home@avphome-VirtualBox:~$ sudo passwd -S user1
user1 P 09/21/2023 0 99999 7 -1
```
Показать состояние учётной записи — информация о состоянии содержит семь полей:

	Первое поле содержит имя учётной записи.
	Второе поле указывает, заблокирована ли учётная запись (L), она без пароля (NP) или у неё есть рабочий пароль (P).
	Третье поле хранит дату последнего изменения пароля (месяц/день/год).
	В последующих четырёх полях (4-7 поля) хранятся: минимальный срок действия пароля в днях до его изменения, максимальное время действия пароля в днях до его смены, количество дней до истечения срока действия пароля, когда пользователь начнет получать предупреждения и, наконец, количество дней после истечения срока действия пароля, когда пользователь будет деактивирован (то есть отключён от системы). Ещё раз: все эти четыре поля имеют размерность дней.
	
Давайте рассмотрим некоторые другие ключи:

	-a, --all — применяется только вместе с -S для вывода статуса всех пользователей.
	-d, --delete — удаляет пароль пользователя, оставляя его пустым. Этот ключ можно применить, чтобы заблокировать пользователя, так как без пароля он и не зайдёт в систему, и не сможет зайти в sudo.
	-e, --expire — делает текущий пароль пользователя устаревшим. При следующей попытке пользователя зайти в систему ему придётся сменить пароль.
	-h, --help — выводит на экран краткую справку.
	
```
root@avphome-VirtualBox:/home/avp-home# passwd user3 && passwd -x 42 user3
```

## USERMOD

применяется для изменения учётной записи пользователя, если пользователь уже существует

root@localhost:/home/mess# usermod ключи логин

 добавление в группу sudo пользователя user1:
 ```
 root@avphome-VirtualBox:/home/avp-home# usermod -aG sudo user1
 ```
 
 Ключи -a, --append и -G, --groups используются только совместно, для добавления пользователя в новую группу. Если надо добавить в несколько групп, то их можно перечислять через запятую.

 

## USERDEL

Для удаления пользователя из системы с помощью userdel используется такой синтаксис:

```
root@avphome-VirtualBox:/home/avp-home# cat /etc/passwd |grep user3
user3:x:1003:1003::/home/user3:/bin/sh
root@avphome-VirtualBox:/home/avp-home# userdel user3
root@avphome-VirtualBox:/home/avp-home# cat /etc/passwd |grep user3
root@avphome-VirtualBox:/home/avp-home#
```

Но при этом, если у пользователя была создана домашняя директория, то она удалена не будет. Чтобы удалить пользователя вместе с домашней директорией, надо использовать ключ  -r, --remove:

А если случилось такое, что пользователь до сих пор активен в системе, то для его удаления нужно применить ключ -f, --force:

```
userdel -rf user2
```

Если требуется посмотреть, какие пользователи в данный момент активны в системе, то стоит применить команду **users**.

Если требуется массовая смена паролей, то для этого будет применяться команда **chpasswd**. Синтаксис будет отличаться от стандартного ввода команд. Сначала вы вводите команду, и курсор переместится на поле вниз. После этого потребуется ввести логин пользователя, а потом, через двоеточие, — пароль. требуется нажать сочетание клавиш Ctrl+D. Оно передаёт терминалу, что ввод данных окончен. Либо можете использовать другой вариант ввода паролей — с помощью текстового файла. Вы создаёте текстовый файл (название файла зависит только от вашей фантазии) с помощью редактора, где вводите логин и пароль в таком же виде, как в команде:

	user1:password1
	user2:password2
	user3:password3

И с помощью команды cat, через pipe (|), как делали с поиском grep по файлу, вы передаёте поток данных в chpasswd. Пример:

```
root@localhost:~# cat polzovateli_i_paroli |  chpasswd
```
***chfn*** — команда изменения информации о пользователе:

root@localhost:~# chfn ключ логин

Ключи к команде:

	-f — полное имя,
	-r — номер комнаты,
	-w — рабочий телефон,
	-h — домашний телефон,
	-o — комментарии,
	-chage — команда для смены срока действия пароля.
	
## CHSH

chsh — команда для смены командной оболочки. Синтаксис:

	root@localhost:~# chsh [-s путь к оболочке] логин
	
```
avp-home@avphome-VirtualBox:~$ cat /etc/passwd |grep user1
user1:x:1001:1001::/home/user1:/bin/sh
user101:x:1002:1002::/home/user101:/bin/sh
user102:x:1003:1003::/home/user102:/bin/bash

avp-home@avphome-VirtualBox:~$ sudo chsh -s /bin/bash user1
avp-home@avphome-VirtualBox:~$ cat /etc/passwd |grep user1
user1:x:1001:1001::/home/user1:/bin/bash
user101:x:1002:1002::/home/user101:/bin/sh
user102:x:1003:1003::/home/user102:/bin/bash
```

Будет полезно также запомнить, что вывести все файлы, принадлежащие пользователю, можно через команду для поиска — **find**, про которую говорилось в прошлом модуле.


## E2.4. Группы

### groupadd

Команда **groupadd** используется для добавления групп

```
root@avphome-VirtualBox:~# groupadd group01
root@avphome-VirtualBox:~# tail -n 1 /etc/group
group01:x:1004:
```
добавим пользователя в группу
```
root@avphome-VirtualBox:~# usermod -aG group01 user1
root@avphome-VirtualBox:~# tail -n 1 /etc/group
group01:x:1004:user1
```

узнаev в каких группах состоит пользователь

```
root@avphome-VirtualBox:~# cat /etc/group |grep user101
user101:x:1002:
group01:x:1004:user1,user101
```

Краткий список существующих ключей:

	-f, --force — этот ключ заставляет команду просто завершиться с успешным статусом. Если вы при создании группы укажете, к примеру, уже существующий gid, то он проигнорирует его и создаст новый, как в случае без указания -g. Может быть удобно, если у вас в системе уже очень много групп и не получится подобрать подходящий идентификатор группы.
	-g,  --gid — создаёт группу с определённым идентификатором gid. Без этого ключа будет создана группа с идентификатором, который станет следующим по порядку, после последней существующей группы. Напомним, что он должен быть от 1000 до 999999999.
	-h,  --help — показывает инструкцию.
	-o,  --non-unique — позволяет создать группу с не уникальным gid.
	-r,  --system — создаёт системную группу (по аналогии с системным пользователем).

Напишите команду для создания группы group10 с gid, на один меньше максимального.

```
root@avphome-VirtualBox:~# groupadd -g 999999998 group10
root@avphome-VirtualBox:~# tail -n 1 /etc/group
group10:x:999999998:
```

### ***groupadd, groupmod, groupdel, groups***

* **groupadd** — создание новой группы.
* **groupmod** — команда для изменения группы. Используется для смены gid или имени группы
* **groupdel** — используется для удаления групп. 
* **groups** - — покажет вам список групп, в которых вы состоите.

**groupadd**: 
```
groupadd -g 2000 group101
```
	-g — числовое значение идентификатора группы. Значение должно быть уникальным, если не задан параметр -o. Значение должно быть не отрицательным. По умолчанию берётся значение больше 999 и больше идентификатора любой другой группы. Значения от 0 и до 999 обычно зарезервированы под системные группы.


**groupmod**:
	-n — смена имени группы. Например, требуется изменить имя группы group0 на group1.
	-g — меняет gid группы.

Например, у нас есть group0. И требуется сменить gid на 999999999, а имя — на group1:
```
root@avphome-VirtualBox:~# cat /etc/group |grep group0
group01:x:1004:user1,user101
root@avphome-VirtualBox:~# groupmod -g 5555 -n gtoup5555 group01
root@avphome-VirtualBox:~# tail -n 1 /etc/group
gtoup5555:x:5555:user1,user101
root@avphome-VirtualBox:~#
```


## E2.5. Права на файлы

	|поле 1|поле 2|поле 3|поле 4|
		-    rw-   rw-   r--

* Поле 1 работает с подсистемой magic и отвечает за тип файла.
* Поле 2 отвечает за доступ на чтение, запись и выполнение для владельца.
* Поле 3 отвечает за доступ на чтение, запись и выполнения для группы и всех пользователей, что входят в группу.
* Поле 4 отвечает за доступ на чтение, запись и выполнение для всех остальных, то есть для тех пользователей, что не входят в группу и не являются владельцами.

		r - право на чтение
		w - право на запись
		x - право на исполнение

### Изменение прав — ***chmod***
chmod (от англ. change mode) — команда для изменения прав доступа к файлам и каталогам.

Синтаксис:

	root@localhost:~# chmod ключи аргументы

Аргументами в данном случае будут являться файлы и/или директории.

***chmod*** будет изменять права доступа для каждого перечисленного файла. Список ключей изменения прав доступа должен разделяться запятыми. Каждая команда начинается с нуля или букв ***ugoa*** (user group other all).

```
root@avphome-VirtualBox:~# useradd user1 && useradd user2 && useradd user3
root@avphome-VirtualBox:~# tail -n 3 /etc/passwd
	user1:x:1004:1004::/home/user1:/bin/sh
	user2:x:1005:1005::/home/user2:/bin/sh
	user3:x:1006:1006::/home/user3:/bin/sh
root@avphome-VirtualBox:~# groupadd group1 && groupadd group2
root@avphome-VirtualBox:~# tail -n 2 /etc/group
	group1:x:5556:
	group2:x:5557:
root@avphome-VirtualBox:~# cd /tmp
root@avphome-VirtualBox:/tmp# mkdir dir1 dir2
	drwxr-xr-x 2 root     root     4096 сен 23 08:42 dir1
	drwxr-xr-x 2 root     root     4096 сен 23 08:42 dir2
```
***d*** - означает директория 

***rwx*** — это значит, что у владельца директории есть права делать в пределах этой директории всё, что угодно.

Потом идут два символа ***-xr***. Это значит, что члены группы могут выполнять в ней файлы и читать файлы.

Прав на запись у них нет, поэтому буква ***w*** не стоит — вместо неё прочерк -. У всех остальных есть только право что-то выполнять в этой директории.
<hr>
Давайте сделаем так, чтобы все остальные могли тоже делать в директории dir1 всё, что угодно. Для этого есть пара способов и команда chmod. Рассмотрим их.

Первый способ:

	root@avphome-VirtualBox:/tmp# chmod o+wrx dir1

Что тут сделано: использовав параметр — букву o (other) — мы поставили +, что значит «Добавить», прописали wrx, что значит «Добавить права на запись, чтение и выполнение». До этого были уже права на выполнение, но такое повторное добавление конфликтов не вызывает.

Второй способ:

	root@avphome-VirtualBox:/tmp# chmod 757 dir1

*два варианта записи прав пользователей — восьмеричная и символьная.*

	000	 0	---		нет						нет
	001	 1	--x		выполнение				чтение файлов и их свойств
	010	 2	-w-		запись					нет
	011	 3	-wx		запись и выполнение		всё, кроме чтения спис ка файлов
	100	 4	r--		чтение					чтение имён
	101	 5	r-x		чтение и выполнение		доступ на чтение
	110	 6	rw-		чтение и запись			чтение имён файлов
	111	 7	rwx		все права				все права


Также стоит обратить внимание на несколько ключей для команды chmod:

	-c, --changes — используя этот ключ, вы увидите подробное описание, для каких файлов и директорий будут меняться права. Его лучше использовать вместе с ключом -R.
	-R, --recursive — рекурсивное изменение прав доступа для каталогов и их содержимого.

Чтобы изменить на них права массово, то есть не применяя отдельно команду к каждому файлу, а также к каждой вложенной директории, если бы они были, надо использовать ключ рекурсии. К примеру, мы хотим сделать так, чтобы для всех файлов в директории и для самой директории ни у кого не было прав, только у root. Для этого стоит сделать так:

root@localhost:~# chmod -R -xrw dir1
И все права будут аннигилированы, в том числе и на директорию.

Важно! Если вы хотите убрать все права файлов и директорий, вложенных в директорию, то надо указывать маску *.

root@localhost:~# chmod -R -xrw dir1/*
Тогда изменения затронут всё внутри директории, но не затронут саму директорию.

	-f, --silent, --quiet — Не выдавать сообщения об ошибке для файлов, чьи права не могут быть изменены. Это также пригодится при массовой замене прав. 

```
root@avphome-VirtualBox:/tmp# cd ~/
root@avphome-VirtualBox:~# su user2
$ exit
root@avphome-VirtualBox:~# cat /etc/passwd |grep user2
user2:x:1005:1005::/home/user2:/bin/sh
root@avphome-VirtualBox:~# chsh -s /bin/bash user2
root@avphome-VirtualBox:~# cat /etc/passwd |grep user2
user2:x:1005:1005::/home/user2:/bin/bash
```
Вошли в систему под пользователем user2, он работает в оболочке sh, выходим и меняем оболочку по умолчанию на bash

```
root@avphome-VirtualBox:~# su user2
user2@avphome-VirtualBox:/root$ cd /tmp
user2@avphome-VirtualBox:/tmp$ touch dir1/test_file1
user2@avphome-VirtualBox:/tmp$ touch dir2/test_file2
touch: невозможно выполнить touch для 'dir2/test_file2': Отказано в доступе
```

в папке tmp создаем новый файл test_file1 в директории dir1, все прошло успешно.

в папке tmp создаем новый файл test_file2 в директории dir2, файл не создан, так как отсутсвуют права на запись 

### chown

chown (англ. change owner) — изменяет владельца и группу файла.

	root@localhost:~# chown [ключ] пользователь[:группа] файл_или_директория

На примере данной команды, если требуется изменить владельца группы на определённого пользователя, к примеру, чтобы у dir1 был владельцем user2, а не root, потребуется сделать:

	root@localhost:~# chown user2 /tmp/dir1
Для того чтобы сменить и владельца, и группу, используйте синтаксис:

	root@localhost:~# chown user2:group1  /tmp/dir1

Какие ключи могут быть полезными:

	-c, --changes — описывает действия для каждого файла, владелец или группа которого изменена.
	-f, --silent, --quiet — не выдавать сообщения об ошибках для файлов, чей владелец не может быть изменён.
	-v, --verbose — подробное описание действия (или отсутствия действия) для каждого файла. То есть отличается от -c тем, что по-любому скажет, был изменён владелец и группа или нет.
	-R, --recuirsive — рекурсивное изменение владельца каталогов и их содержимого. Работает так же, как аналогичный ключ из прошлой команды, то есть изменяет массово.

### chgrp

chgrp (англ. change group)  — позволяет непривилегированным пользователям менять членство групп файлов, но только для тех групп, членами которых они являются. То есть существует пользователь worker. Он является членом групп worker и sudo. Этот пользователь создал файл, и поэтому файлу присвоена группа пользователя worker. И благодаря chgrp он может сменить группу на sudo, потому что также является её членом:

	user1@localhost:~# chgrp группа файл_или_директория.


## E2.6. Время и даты
```
root@avphome-VirtualBox:~# date
	Вс 24 сен 2023 08:28:31 EET
```
ключи:
* -d, --date=СТРОКА — показывает не текущее время, а время, описанное заданной СТРОКОЙ. Может пригодиться при написании скриптов на bash. Например, date --date='Thu 20 Nov 2020 10:27:59 PM MSK' или date -d 202001012.
* -f, --file=ФАЙЛ — соответствует применению --date для каждой строки ФАЙЛА. Опять же, может пригодиться для использования на bash.
* -r, --reference=ФАЙЛ — показывает время последнего изменения ФАЙЛА.
* -s, --set — устанавливает время, описанное после ключа. Но эту функцию лучше не использовать, для этого существуют другие, более действенные команды.

	root@avphome-VirtualBox:~#   date -s 030117562020

Здесь мы установили время и дату на 3 января 2020 года на 17 часов 56 минут.

Для установки времени при отсутствии синхронизации с NTP-сервером лучше использовать команду timedatectl.
```
root@avphome-VirtualBox:~# timedatectl
               Local time: Вс 2023-09-24 08:35:24 EET
           Universal time: Вс 2023-09-24 06:35:24 UTC
                 RTC time: Вс 2023-09-24 06:35:24
                Time zone: Europe/Kaliningrad (EET, +0200)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no
```

	root@avphome-VirtualBox:~# timedatectl set-ntp off
	root@avphome-VirtualBox:~# timedatectl set-ntp on
	root@avphome-VirtualBox:~# timedatectl list-timezones |grep Kaliningrad
		Europe/Kaliningrad

	root@avphome-VirtualBox:~# timedatectl set-timezone Europe/Moscow
	root@avphome-VirtualBox:~# timedatectl
				Local time: Вс 2023-09-24 09:42:10 MSK
			Universal time: Вс 2023-09-24 06:42:10 UTC
					RTC time: Вс 2023-09-24 06:42:09
					Time zone: Europe/Moscow (MSK, +0300)
			System clock synchronized: yes
				NTP service: inactive
			RTC in local TZ: no

root@localhost:~# timedatectl [ключи] [команды] [аргументы] 

* ***status***	Команда по умолчанию. С ней показывает то же самое, что и просто timedatectl.
* ***show***	Показывает настройки системных часов, RTC, активна ли синхронизация сетевого времени. Если команда не указывается, то она подразумевается по умолчанию.
* ***set-time***	Установка времени. Время вводится после команды в формате "2012-10-30 18:17:16".
* ***set-timezone***	Устанавливает нужную временную зону (из прошлого примера).
* ***list-timezones***	Показывает все доступные временные зоны (как в прошлом примере).
* ***set-local-rtc***	Установка RTC. Вводится число из двоичной системы счисления: 0 — если система настроена на поддержание всемирного времени, и 1 — если требуется поддерживать системой локальное время. Либо yes, либо no.
* ***set-ntp***	Из примера, указывает, активна ли синхронизация по сети, протоколу NTP. Вводятся значения off и on.
* ***timesync-status***	Показывает дополнительную системную информацию, например, какой установлен сервер синхронизации времени, его адрес, как часто с ним происходит синхронизация и прочее.
* ***show-timesync***	Показывает то же, что и прошлая команда, но в машинном формате.
* ***ntp-servers***	Устанавливает другие сервера для интерфейса синхронизации времени, какие вы укажете.
* ***revert***	Восстанавливает сервера обратно, если они были установлены предыдущей командой (ntp-servers).

А также перечислим несколько полезных ключей:

	--monitor — если вызывается timesync-status с этим ключом, то он не просто выведет его на экран терминала один раз, а будет постоянно мониторить. Выйти из этого режима можно с помощью Сtrl+С.
	-a, --all — показывает дополнительную информацию, где её можно вывести.
	-h, --help — справка.
	hwclock — у

Вывести системное время:

	root@localhost:~#  hwclock
	2020-10-08 01:29:45.151002+03:00
Устанавливает системное время в соответствии с аппаратными часами:

	root@localhost:~# hwclock -hctosys

Устанавливает конкретное значение аппаратного времени:

	root@localhost:~# hwclock --set --date="2011-01-25 08:55:01"

Кратко просмотрим функции:

* -r, --show — показывает аппаратное время.
* --set — устанавливает системное время в соответствии с данными после ключа --date, как в примере.
* -s, --hctosys — устанавливает системное время в соответствии с аппаратными часами.
* -w, --systohc — устанавливает аппаратное время в соответствии с системным временем.
* -u, --utc — устанавливает аппаратные часы в UTC.
* -l, --localtime — устанавливает аппаратные часы в локальное время.
* -h, --help — краткая справка.
В Linux аппаратное время совпадает с системным только в том случае, если смещение часового пояса составляет 0 часов, и не используется летнее время. В других случаях при установке времён на аппаратных часах следует учитывать разницу в часовых поясах относительно UTC.

***times*** — информирует пользователя о том, сколько потребуется времени для выполнения любых команд. В первой строке указывается время для интерпретатора, во второй — время, которое нужно выполняемым командам.
```
root@localhost:~# times
0m0.032s 0m0.069s
0m0.703s 0m0.221s
```

	hwclock			Изменение аппаратного времени сервера.
	date			Демонстрация и изменение времени.
	times			Запись времени процесса.
	timedatectl		Управление временем, датой, временными зонами